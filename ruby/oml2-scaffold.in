#!/usr/bin/ruby
#
# Copyright 2009-2013 National ICT Australia (NICTA), Australia
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

#
# This program is taking an OMF application definition and creates
# various files to simplify building applications which use OML.
#

PROG = 'oml2-scaffold'
VERSION = "@VERSION@"
VERSION_STRING = "#{PROG} V#{VERSION}"
COPYRIGHT = "Copyright 2009-2013, NICTA"

require 'stringio'
require 'optparse'

@@integer_alias = :int32

def run()
  if File.basename($PROGRAM_NAME) == 'oml2_scaffold'
    old = File.basename($PROGRAM_NAME)
    new = old.gsub('_', '-')
    $stderr.puts "WARN\t'#{old}' is a deprecated name for this script; use '#{new}' instead."
  end

  opts = OptionParser.new
  opts.banner = %Q|
Generate C code for an OML application from an application definition file

  Usage: #{$0} [OPTIONS] [app_file]

|

  output = []
  app_name = 'unknown'
  create_app = false
  force = false

  opts.on('-a', "--app PROG_NAME",
      "Create a skeleton OMF application definition file ") do |name|
    create_app = true
    app_name = name
  end
  opts.on('-f', "--force",
      "Do not check if a file would be overwritten") do
    force = true
  end
  opts.on('-l', "--long",
      "Alias :int and :integer to underlying :long") do
    @@integer_alias = :long
  end
  opts.on('-i', "--int32",
      "Alias :int and :integer and :long to underyling :int32 (default)") do
    @@integer_alias = :int32
  end
  opts.on(nil, "--oml",
      "Create the oml header file defining all measurement points") do
    output << :oml
  end
  opts.on(nil, "--opts",
      "Create the popt header file for all application properties") do
    output << :popt
  end
  opts.on("--make",
      "Create a skeleton Makefile for this application") do
    output << :make
  end
  opts.on("--main",
      "Create a skeleton main file for this application") do
    output << :main
  end

  opts.on_tail("-h", "--help", "Show this message") do $stderr.write(opts); exit end
  opts.on_tail("-v", "--version", "Show the version\n") do
    $stderr.puts (VERSION_STRING)
    exit
  end

  begin
    rest = opts.parse(ARGV)
  rescue OptionParser::InvalidOption => ex
    $stderr.puts ex
    exit -1
  rescue OptionParser::MissingArgument => ex
    $stderr.puts ex
    exit -1
  end

  if rest.size > 1
    $stderr.puts "ERROR\tToo many arguments"
    $stderr.write(opts.banner)
    exit -1
  end
  app_file = rest[0]

  if create_app
    if app_file
      $stderr.puts "ERROR\tDon't specify app_file when asking to create one"
      exit -1
    end
    uri = "#{ENV['USER']}:app:#{app_name}"
    ad = AppDefinition.new uri, app_name
    app_file = "#{app_name}.rb"
    if File.exists?(app_file) && !force
      $stderr.puts "ERROR\tFile #{app_file} already exists. Use --force to overwrite"
      exit -1
    else
      File.open(app_file, 'w') do |f|
	ad.write_app_def(f, app_file)
      end
    end
    $stderr.puts "INFO\tCreated #{app_file}"
    $stderr.puts "INFO\tYou can now generate a skeleton makefile with '#{$PROGRAM_NAME} --main #{app_file}' and its associated Makefile with '#{$PROGRAM_NAME} --make #{app_file}'"
    AppDefinition.remove ad
  end

  unless app_file
    $stderr.puts "ERROR\tMissing app_file"
    exit -1
  end

  app_file = File.expand_path(app_file)
  unless File.readable?(app_file)
    $stderr.puts "ERROR\tCan't find or open application description file #{app_file}"
    exit -1
  end
  load(app_file)
  AppDefinition.each do |app|
    output.each do |type|
      case type
      when :oml
    fname = "#{app.name}_oml.h"
    File.open(fname, 'w') do |f|
      app.write_oml_h(f)
    end
    $stderr.puts "INFO\tCreated #{fname}"
      when :popt
    fname = "#{app.name}_popt.h"
    File.open(fname, 'w') do |f|
      app.write_opts_h(f)
    end
    $stderr.puts "INFO\tCreated #{fname}"
      when :make
    fname = "Makefile"
    if File.exists?(fname) && !force
      $stderr.puts "ERROR\tFile #{fname} already exists. Use --force to overwrite"
      exit -1
    else
      File.open(fname, 'w') do |f|
        app.write_makefile(f)
      end
      $stderr.puts "INFO\tCreated #{fname}"
    end
      when :main
	fname = "#{app.name}.c"
	if (File.exists?(fname) || File.exists?("config.h")) && !force
	  $stderr.puts "ERROR\t#{fname} or config.h already exist. Use --force to overwrite"
	  exit -1
	else
	  File.open(fname, 'w') do |f|
	    app.write_main(f)
	  end
	  File.open('config.h', 'w') do |f|
	    app.write_config(f)
	  end
	  $stderr.puts "INFO\tCreated #{fname} and config.h"
	end
      else
	$stderr.puts "ERROR\tUnsupported output format #{type}"
	exit -1
      end
    end
  end
end

class Property < Struct.new(:long_name, :descr, :letter_name, :opts)

  def write_opts_t(s)
    # FIXME: Duplicated code
    if @@integer_alias == :long
      integerval = "long"
      integertype = "long"
    else
      integerval = "int32";
      integertype = "int32_t";
    end
    ctypes = {
      :flag => "int",
      "flag" => "int",
      :string => "char*",
      "string" => "char*",
      :long => "long",
      "long" => "long",
      :integer => "int",
      "integer" => "int",
      :int => "int",
      "int" => "int",
      :int32 => "int",
      "int32" => "int",
      :uint32 => "unsigned int",
      "uint32" => "unsigned int",
      :int64 => "int",
      "int64" => "int",
      :uint64 => "unsigned int",
      "uint64" => "unsigned int",
      :double => "double",
      "double" => "double",
      # XXX: Deprecated
      :float => "double",
      "float" => "double",
      :real => "double",
      "real" => "double",
      :blob => "void*",
      "blob" => "void*",
      # guid
      :guid => "guid_t",
      "guid" => "guid_t",
    }
    var_name = (@impl[:var_name] ||= long_name)
    s.puts "  #{ctypes[opts[:type]]} #{var_name};"
  end

  def default_value()
    defaults = {
      :flag => "0",
      "flag" => "0",
      :string => "\"\"",
      "string" => "\"\"",
      :long => "0",
      "long" => "0",
      :integer => "0",
      "integer" => "0",
      :int => "0",
      "int" => "0",
      :int32 => "0",
      "int32" => "0",
      :uint32 => "0",
      "uint32" => "0",
      :int64 => "0",
      "int64" => "0",
      :uint64 => "0",
      "uint64" => "0",
      :double => "0.",
      "double" => "0.",
      # XXX: Deprecated
      :float => "0.",
      "float" => "0.",
      :real => "0.",
      "real" => "0.",
      # XXX see opttypes in arg_info()
      :blob => "\"\"",
      "blob" => "\"\"",
      :guid => "guid_t",
      "guid" => "guid_t",
    }
    return defaults[opts[:type]]
  end

  def popt_def()
    a = []
    a << "\"#{long_name}\""
    a << (letter_name ? "'#{'%c' % letter_name}'" : 'NULL')
    a << arg_info
    a << "&g_opts_storage.#{@impl[:var_name] || long_name}"
    if (val = @impl[:popt_val])
      a << "\'#{val}\'"
    else
      a << 0
    end
    a << "\"#{descr}\""
    a << "\"#{opts[:unit]}\"" if opts[:unit]
    "  { #{a.join(', ')}},"
  end

  def arg_info()
    opttypes = {
      :flag => "POPT_ARG_NONE",
      "flag" => "POPT_ARG_NONE",
      :string => "POPT_ARG_STRING",
      "string" => "POPT_ARG_STRING",
      :long => "POPT_ARG_LONG",
      "long" => "POPT_ARG_LONG",
      :integer => "POPT_ARG_INT",
      "integer" => "POPT_ARG_INT",
      :int => "POPT_ARG_INT",
      "int" => "POPT_ARG_INT",
      :int32 => "POPT_ARG_INT",
      "int32" => "POPT_ARG_INT",
      :uint32 => "POPT_ARG_INT",
      "uint32" => "POPT_ARG_INT",
      :int64 => "POPT_ARG_INT",
      "int64" => "POPT_ARG_INT",
      :uint64 => "POPT_ARG_INT",
      "uint64" => "POPT_ARG_INT",
      :double => "POPT_ARG_DOUBLE",
      "double" => "POPT_ARG_DOUBLE",
      # XXX: Deprecated
      :float => "POPT_ARG_DOUBLE",
      "float" => "POPT_ARG_DOUBLE",
      :real => "POPT_ARG_DOUBLE",
      "real" => "POPT_ARG_DOUBLE",
      # XXX: Not sure what we can do with it so far
      :blob => "POPT_ARG_STRING",
      "blob" => "POPT_ARG_STRING",
      # guid
      :guid => "guid_t",
      "guid" => "guid_t"
    }
    return opttypes[opts[:type]]
  end

  def initialize(long_name, descr, letter_name, opts = {})
    super
    type = (opts[:type] || :int).to_sym
    type = :int if type == :integer
    opts[:type] = type
    @impl = opts[:impl] || {}
  end
end


class AppDefinition
  @@instances = []

  def self.remove (app_def)
    @@instances.delete app_def
  end

  def self.each(&block)
    @@instances.each &block
  end

  attr_accessor :uri, :name, :shortDescription, :description, :path

  def version(major, minor = 0, revision = 0)
    @version = [major, minor, revision]
  end

  def defProperty(long_name, descr, letter_name, opts = {})
    @properties << Property.new(long_name, descr, letter_name, opts)
  end

  def defMeasurement(name, &block)
    @mps << MeasurementPoint.new(name, &block)
  end

  def initialize(uri, name, &block)
    @uri = uri
    @name = name || @uri.split(':')[-1]
    @properties = []
    @mps = []
    @@instances << self
    block.call(self) if block
  end

  def write_oml_decl(s)
    @mps.each do |mp|
      s.puts ""
      mp.write_oml_h(s)
    end
  end

  def write_oml_mps_t(s)
    @mps.each do |mp|
      s.puts "  OmlMP* #{mp.name};"
    end
  end

  def write_oml_register(s)
    @mps.each do |mp|
      n = mp.name
      s.puts "  g_oml_mps_#{template(:app_cstring)}->#{n} = omlc_add_mp(\"#{n}\", oml_#{n}_def);"
    end
  end

  def write_oml_helper_functions(s)
    @mps.each do |mp|
      mp.write_oml_helper_function(s)
    end
  end

  def write_opts_default(s)
    a = []
    @properties.each do |p|
      a << p.default_value()
    end
    s.write a.join(', ')
  end

  def write_opts_options(s)
    @properties.each do |p|
      s.puts p.popt_def()
    end
  end

  def template(name)
    s = StringIO.new
    case name
    when :app_name
      return @name
    when :app_cstring
      return @name.gsub("-", "_")
    when :app_urn
      return "#{ENV['USER'] || 'xxx'}:app:#{@name}"
    when :app_path
      return @path
    when :options_t
      @properties.each do |p|
    p.write_opts_t(s)
      end
    when :options_default
      write_opts_default(s)
    when :options_list
      write_opts_options(s)
    when :oml_decl
      write_oml_decl(s)
    when :oml_mps_t
      write_oml_mps_t(s)
    when :oml_register
      write_oml_register(s)
    when :oml_helpers
      write_oml_helper_functions(s)
    else
      raise "Undefined template #{name}"
    end
    s.string
  end

  def write_file_header(stream = $stdout, notice="Please do not edit.")
    stream.puts %Q|/*
 * This file was automatically generated by #{PROG} #{VERSION}
 * for #{template(:app_name)} version #{@version[0]}.#{@version[1]}.#{@version[2]}.
 * #{notice}
 */|
  end

  def write_oml_h(stream = $stdout)
    hdrsentinel = template(:app_cstring).upcase
    write_file_header(stream)
    stream.puts %Q|
#ifndef #{hdrsentinel}_OML_H
#define #{hdrsentinel}_OML_H

#ifdef __cplusplus
extern "C" {
#endif

/* Get size_t and NULL from <stddef.h>.  */
#include <stddef.h>

#include <oml2/omlc.h>

typedef struct {
#{template(:oml_mps_t)}
} oml_mps_t;


#ifdef OML_FROM_MAIN
/*
 * Only declare storage once, usually from the main
 * source, where OML_FROM_MAIN is defined
 */
#{template(:oml_decl)}
static oml_mps_t g_oml_mps_storage;
oml_mps_t* g_oml_mps_#{template(:app_cstring)} = &g_oml_mps_storage;

static inline void
oml_register_mps()
{
#{template(:oml_register)}
}

#else
/*
 * Not included from the main source,
 * only declare the global pointer to the MPs
 */

extern oml_mps_t* g_oml_mps_#{template(:app_cstring)};

#endif /* OML_FROM_MAIN */

#{template(:oml_helpers)}

/* Compatibility with old applications */
#ifndef g_oml_mps
# define g_oml_mps	g_oml_mps_#{template(:app_cstring)}
#endif

#ifdef __cplusplus
}
#endif

#endif /* #{hdrsentinel}_OML_H */
|
  end

  def write_opts_h(stream = $stdout)
    hdrsentinel = template(:app_cstring).upcase
    write_file_header(stream)
    stream.puts %Q|
#ifndef #{hdrsentinel}_OPTS_H
#define #{hdrsentinel}_OPTS_H

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
#{template(:options_t)}
} opts_t;

#ifndef USE_OPTS

opts_t* g_opts;

#else

static opts_t g_opts_storage = {#{template(:options_default)}};
opts_t* g_opts = &g_opts_storage;

/* Only the file containing the main() function should come through here */

#include <popt.h>

struct poptOption options[] = {
  POPT_AUTOHELP
#{template(:options_list)}
  { NULL, 0, 0, NULL, 0 }
};

#endif /* USE_OPTS */

#ifdef __cplusplus
}
#endif

#endif /* #{hdrsentinel}_OPTS_H */
|
  end

  def write_makefile(stream = $stdout)
    stream.puts %Q?# This file was automatically generated by #{PROG} #{VERSION}
PROGRAM = #{template(:app_name)}
SRCS = ${PROGRAM}.c

RUNARGS = --loop --delay 1

BINDIR = $(DESTDIR)#{File.dirname(template(:app_path))}/

CFLAGS = -Wall -Werror -g -I. # -I/usr/local/include
LDFLAGS = # -L/usr/local/lib
LIBS = -loml2 -lpopt

SCAFFOLD = #{$PROGRAM_NAME}

OBJS = $(SRCS:%.c=%.o)

all: build
build: $(PROGRAM)

install: $(PROGRAM)
	install -m 755 $(PROGRAM) $(BINDIR)

clean:
	rm -rf $(PROGRAM)
	rm -rf $(OBJS)

realclean: clean
	rm -rf $(PROGRAM)_popt.h $(PROGRAM)_oml.h

run: $(PROGRAM)
	./$(PROGRAM) $(RUNARGS) --oml-collect file:-

%.o: %.c
	$(CC) -c $(CFLAGS) $< -o $@


$(PROGRAM): $(OBJS)
	$(CC) -o $@ $^ $(LDFLAGS) $(LIBS)

$(PROGRAM).o: config.h $(PROGRAM)_popt.h $(PROGRAM)_oml.h
$(PROGRAM)_popt.h: $(PROGRAM).rb
	$(SCAFFOLD) --opts $<
$(PROGRAM)_oml.h: $(PROGRAM).rb
	$(SCAFFOLD) --oml $<

.PHONY: all build install clean realclean
?
  end

  def write_main(stream = $stdout)
    write_file_header(stream, "Please edit to suit your needs; the run() function should contain application code.")
    stream.puts %Q|
#include <unistd.h> /* Needed for sleep(3) in run() */

#define USE_OPTS
#include <popt.h>
#include "#{template(:app_name)}_popt.h"

#include <oml2/omlc.h>
#define OML_FROM_MAIN
#include "#{template(:app_name)}_oml.h"

#include "config.h"

/* Do application-specific work here */
void
run(opts_t* opts, oml_mps_t* oml_mps)
{
  long val = 1;

  do {
    /* The oml_inject_MPNAME() helpers are defined in #{template(:app_name)}_oml.h*/
|
    @mps.each do |mp|
      mp.write_inject_example(stream)
    end
    stream.puts %Q|
    val += 2;
    sleep(1);
  } while (1);
}

int
main(int argc, const char *argv[])
{
  int c;

  omlc_init("#{template(:app_name)}", &argc, argv, NULL);

  /* Parse command line arguments */
  poptContext optCon = poptGetContext(NULL, argc, argv, options, 0); /* options is defined in #{template(:app_name)}_popt.h */
  while ((c = poptGetNextOpt(optCon)) > 0) {}

  /* Initialise measurement points */
  oml_register_mps(); /* Defined in #{template(:app_name)}_oml.h */
  omlc_start();

  run(g_opts, g_oml_mps_#{template(:app_cstring)}); /* Do some work and injections, see above */

  omlc_close();

  return(0);
}

/*
 Local Variables:
 mode: C
 tab-width: 2
 indent-tabs-mode: nil
 End:
 vim: sw=2:sts=2:expandtab
*/
|
  end

  def write_config(stream = $stdout)
    write_file_header(stream, "")
    stream.puts %Q|
#define PACKAGE			"#{template(:app_name)}"
#define VERSION			"#{@version[0]}.#{@version[1]}.#{@version[2]}"

/* Provide compatibility with autoconf-generated config.h */
#define PACKAGE_NAME		PACKAGE
#define PACKAGE_TAR_NAME	PACKAGE
#define PACKAGE_VERSION		VERSION

|
  end

  def write_app_def(stream = $stdout, app_file="[FILENAME]")
    stream.puts %@# This file was automatically generated by #{PROG} #{VERSION}

defApplication('#{template(:app_urn)}', '#{template(:app_name)}') do |app|

  app.version(1, 0, 0)
  app.shortDescription = 'A short description'
  app.description = %{
A longer description describing in more detail what this application
is doing and useful for.
}
  app.path = "/usr/local/bin/#{template(:app_name)}"

  # Declare command-line arguments; generate Popt parser with
  #  #{PROG} --opts #{app_file}
  app.defProperty('loop', 'Create periodic result', ?l,
        :type => :flag, :impl => { :var_name => 'loop' })
  app.defProperty('delay', 'Delay between consecutive measurements', ?d,
        :type => :int, :unit => 'seconds',
        :impl => { :var_name => 'delay' })

  # Declare measurement points; generate OML injection helpers with
  #  #{PROG} --oml #{app_file}
  app.defMeasurement("sensor") do |mp|
    mp.defMetric('val', 'int32')
    mp.defMetric('inverse', 'double')
    mp.defMetric('name', 'string')
  end

end

# Local Variables:
# mode:ruby
# End:
# vim: ft=ruby:sw=2
@
  end
end

class Metric < Struct.new(:name, :type, :opts)

  @@warnings = Hash.new

  def c_type
    case type.to_sym
    when :int, :integer
      if @@integer_alias == :long and @@warnings[type.to_sym] == nil
        $stderr.write("WARN\tCommand line switch --long makes :#{type.to_sym} an alias for :long, but :long is deprecated; new applications should use :int32, :uint32, :int64, :uint64 instead")
        @@warnings[type.to_sym] = true
      end
    when :long
      if @@warnings[type.to_sym] == nil
        $stderr.write("WARN\tType :long is deprecated; new applications should use :int32, :uint32, :int64, :uint64 instead")
        @@warnings[type.to_sym] = true
      end
    end

    case type.to_sym
    when :string
      "OML_STRING_VALUE"
    when :int, :integer
      case @@integer_alias
      when :long
        "OML_LONG_VALUE"
      when :int32
        "OML_INT32_VALUE"
      end
    when :long
      case @@integer_alias
      when :long
        "OML_LONG_VALUE"
      when :int32
        "OML_INT32_VALUE"
      end
    when :float, :double, :real
      "OML_DOUBLE_VALUE"
    when :int32
      "OML_INT32_VALUE"
    when :uint32
      "OML_UINT32_VALUE"
    when :int64
      "OML_INT64_VALUE"
    when :uint64
      "OML_UINT64_VALUE"
    when :blob
      "OML_BLOB_VALUE"
    when :guid
      "OML_GUID_VALUE"
    else
      $stderr.write("ERROR\tUnknown type #{type}")
      exit -1
    end
  end
end

class MeasurementPoint
  attr_reader :name

  def defMetric(name, type, opts = {})
    @ms << Metric.new(name, type, opts)
  end

  def initialize(name, &block)
    @name = name
    @ms = []
    if block
      block.call(self)
    end
  end

  def write_oml_h(stream)
    stream.puts "static OmlMPDef oml_#{@name}_def[] = {"
    @ms.each do |m|
      stream.puts "  {\"#{m.name}\", #{m.c_type}},"
    end
    stream.puts "  {NULL, (OmlValueT)0}"
    stream.puts "};"
  end

  def write_oml_helper_function(stream)
    # FIXME: Duplicated code
    if @@integer_alias == :long
      integerval = "long"
      integertype = "long"
    else
      integerval = "int32";
      integertype = "int32_t";
    end
    ctypes = {
      # We know we don't modify these
      :string => "const char*",
      "string" => "const char*",
      :long => "long",
      "long" => "long",
      :integer => integertype,
      "integer" => integertype,
      :int32 => "int32_t",
      "int32" => "int32_t",
      :uint32 => "uint32_t",
      "uint32" => "uint32_t",
      :int64 => "int64_t",
      "int64" => "int64_t",
      :uint64 => "uint64_t",
      "uint64" => "uint64_t",
      :double => "double",
      "double" => "double",
      :float => "double",
      "float" => "double",
      :real => "double",
      "real" => "double",
      # Ditto
      :blob => "const void*",
      "blob" => "const void*",
      # Ditto for guid
      :guid => "guid_t",
      "guid" => "guid_t",
    }
    sets = {
      :string => "string",
      "string" => "string",
      :long => "long",
      "long" => "long",
      :integer => integerval,
      "integer" => integerval,
      :int32 => "int32",
      "int32" => "int32",
      :uint32 => "uint32",
      "uint32" => "uint32",
      :int64 => "int64",
      "int64" => "int64",
      :uint64 => "uint64",
      "uint64" => "uint64",
      :double => "double",
      "double" => "double",
      :float => "double",
      "float" => "double",
      :real => "double",
      "real" => "double",
      :blob => "blob",
      "blob" => "blob",
      :guid => "guid",
      "guid" => "guid"
    }

    stream.print "static inline void
oml_inject_#{@name}(OmlMP* mp"
    @ms.each do |m|
      stream.print ", #{ctypes[m.type]} #{m.name}"
      if m.type == :blob || m.type == "blob"
	stream.print ", size_t #{m.name}_len"
      end
    end
    stream.puts ")\n{"
    stream.puts "  OmlValueU v[#{@ms.length}];\n\n"
    stream.puts "  omlc_zero_array(v, #{@ms.length});\n\n"
    i = 0
    @ms.each do |m|
      stream.print "  omlc_set_#{sets[m.type]}(v[#{i}], #{m.name}"
      if m.type == :blob || m.type == "blob"
	stream.print ", #{m.name}_len"
      end
      stream.puts ");"
      i = i + 1
    end
    stream.puts "\n  omlc_inject(mp, v);\n\n"
    i = 0
    @ms.each do |m|
      if m.type == :string || m.type == "string" || m.type == :blob || m.type == "blob"
	stream.puts "  omlc_reset_#{sets[m.type]}(v[#{i}]);"
      end
      i = i + 1
    end
    stream.puts "}\n\n"
  end

  def write_inject_example(stream)
    if @@integer_alias == :long
      integerval = "val"
    else
      integerval = "(int32_t)-val";
    end
    vals = {
      :string => '"foo"',
      "string" => '"foo"',
      :long => "val",
      "long" => "val",
      :integer => integerval,
      "integer" => integerval,
      :int32 => "(int32_t)-val",
      "int32" => "(int32_t)-val",
      :uint32 => "(uint32_t)val",
      "uint32" => "(uint32_t)val",
      :int64 => "(int64_t)-val",
      "int64" => "(int64_t)-val",
      :uint64 => "(uint64_t)val",
      "uint64" => "(uint64_t)val",
      :double => "1.0 / val",
      "double" => "1.0 / val",
      :float => "1.0 / val",
      "float" => "1.0 / val",
      :real => "1.0 / val",
      "real" => "1.0 / val",
      :blob => 'NULL, 0',
      "blob" => 'NULL, 0',
      :guid => "OMLC_GUID_NULL",
      "guid" => "OMLC_GUID_NULL",
    }

    stream.print "    oml_inject_#{@name}(oml_mps->#{@name}"
    i = 0
    @ms.each do |m|
      stream.print ", #{vals[m.type]}"
      i = i + 1
    end
    stream.print ");\n"
  end


end


def defApplication(uri, name = nil, &block)
  AppDefinition.new(uri, name, &block)
end

run

# vim: sw=2
